target C {
  platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
  },
  threading: false,
}

import Display from "lib/Display.lf"
preamble {=
  #include <stdio.h>
  #include <pico/stdlib.h>
  #include <hardware/gpio.h>
  #include <hardware/uart.h>
  #include <hardware/structs/uart.h>

  #define BAUD_RATE 9600
  #define UART_TX_PIN 28
  #define UART_RX_PIN 29
  #define MAX_MSG_LENGTH 100
  
  // COMMANDS TO POLOLU GO HERE
  static char SET_NAME_COMMAND[10] = "SET_NAME:";

  // Function to send a message. The message that was transmitted is written to transmitted_message
  static void transmitMessage(uart_inst_t *uart, char *message, char *transmitted_message) {
    int index = 0;
    while (*message && index < MAX_MSG_LENGTH) {
      uart_putc(uart, *message);
      transmitted_message[index] = *message;
      index++;
      message++;
    }
    uart_putc(uart, '\r'); // Carriage return
    transmitted_message[index] = '\0';
  }

  // Function to write response from UART to received_message
  static void receiveMessage(uart_inst_t *uart, char *received_message) {
    int index = 0;
    char received_char = 'a'; //'a' is just to initialize received_char to a character that is not \r
    char end_char = '\r';
    if (uart_is_readable(uart)) {
      while (received_char != end_char) { 
        received_char = uart_getc(uart);
        if (index < MAX_MSG_LENGTH - 1 && received_char != end_char) {
          received_message[index] = received_char;
          index += 1;
        }
      }
    }
    received_message[index] = '\0'; // Null terminate the string
  }
=}

main reactor {
  timer t(0, 50 ms);
  state led_on:bool = false;
  state reply:char[100] = "";
  state transmitted_message:char[100] = "";
  state received_message:char[100] = "";
  state name: char[100] = ""
  disp = new Display();

  reaction(startup) {=
    uart_init(uart0, BAUD_RATE);
    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);
    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);

    gpio_init(PICO_DEFAULT_LED_PIN);
    gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);

    // Clear UART buffer
    while (uart_is_readable(uart0)) {
        uart_getc(uart0);
    }

  =}

  reaction(t) -> disp.line0, disp.line1, disp.line2 {=
    lf_set(disp.line0, self->name);

    // Display last transmitted message
    static char buf_sent[17];
    snprintf(buf_sent, 17, "S:%s", self->transmitted_message);
    lf_set(disp.line1, buf_sent);

    // Display last received message
    static char buf_received[17];
    printf("R: %s\n", self->received_message);
    snprintf(buf_received, 17, "R:%s", self->received_message);
    printf("B: %s\n", buf_received);
    lf_set(disp.line2, buf_received);
    
    // LED Blink
    self->led_on = !self->led_on;
    gpio_put(PICO_DEFAULT_LED_PIN, self->led_on);
  =}

  initial mode RECEIVING {
    reaction(t) -> REPLYING {=
      // Read from UART if readable
      if (uart_is_readable(uart0)) {
        receiveMessage(uart0, self->received_message);
        if (strncmp(SET_NAME_COMMAND, self->received_message, strlen(SET_NAME_COMMAND)) == 0) {
          strcpy(self->name, self->received_message + strlen(SET_NAME_COMMAND));
          snprintf(self->reply, 100, "Name:%s", self->name);
          lf_set_mode(REPLYING);
        } else {
          self->reply = "Message Received";
        }
        lf_set_mode(REPLYING);
      }
    =}
  }

  mode REPLYING {
    reaction(t) -> RECEIVING {=
      transmitMessage(uart0, self->reply, self->transmitted_message);
      lf_set_mode(RECEIVING);
    =}
  }
}