target C {
    platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
    },
    threading: false,
  }
  
  import Display from "lib/Display.lf"
  import Motors from "lib/Motors.lf"
  import Encoders from "lib/Encoders.lf"
  import GyroAngle from "lib/IMU.lf"
  import AngleToDistance from "lib/AngleToDistance.lf"
  import Line from "lib/Line.lf"
  
  preamble {=
    #include <math.h>
    #include <stdlib.h>
    #include <stdio.h>
    #include <pico/stdlib.h>
    #include <hardware/gpio.h>
    #include <hardware/uart.h>
    #include <hardware/structs/uart.h>

    #define BAUD_RATE 9600
    #define UART_TX_PIN 28
    #define UART_RX_PIN 29
    #define MAX_MSG_LENGTH 100

    #define RED_LED_PIN 7
    #define YELLOW_LED_PIN 27
    #define GREEN_LED_PIN 24

  =}
  
  main reactor {
    state transmitted_message:char[100] = "";
    state received_message:char[100] = "";
    state previousDistance:float = 0
    state previousAngle:float = 0
    state next_mode:char[100] = "";
    state leds_on:int = 0
    state leds_speed:float = 0.0
    state speed:float = 0.0
    state target_x:int = 0
    state target_y:int = 0
    state degrees:int = 0
    state leds_blink:int = 0
    state i:int = 0
    state leds_state:int = 0
    state calibration_speed:float = 0.0
    state x: int = 0
    state y: int = 0
    state threshold: int = 200
    state one: int = 0
    state two: int = 0
    state three: int = 0
    state four: int = 0
    state five: int = 0
    state commandReceived:bool = false
  
    m = new Motors()
    e = new Encoders()
    d = new Display()
    gyro = new GyroAngle()
    angleToDistanceL = new AngleToDistance()
    angleToDistanceR = new AngleToDistance()
    line = new Line()
  
    timer t(0, 50 ms)
    timer end_calibration(4 s)

    method setCommand() {=
      char *token = strtok(self->received_message, ",");
      self->next_mode = token;
      token = strtok(NULL, ",");
      self->speed = atof(token);
      token = strtok(NULL, ",");
      self->degrees = atoi(token);
      token = strtok(NULL, ",");
      self->leds_on = atoi(token);
      token = strtok(NULL, ",");
      self->target_x = atoi(token);
      token = strtok(NULL, ",");
      self->target_y = atoi(token);
      token = strtok(NULL, ",");
      self->leds_blink = atoi(token);
      token = strtok(NULL, ",");
      self->calibration_speed = 0.5f;
      token = strtok(NULL, ",");
      self->commandReceived = true;

      // if (self->next_mode == "CALIBRATION") {
      //   lf_set_mode(CALIBRATION);
      // } else if (self->next_mode == "DRIVE") {
      //   lf_set_mode(NEW_DRIVING);
      // } else if (self->next_mode == "ROTATE") {
      //   lf_set_mode(NEW_ROTATING);
      // } else if (self->next_mode == "STOP") {
      //   lf_set_mode(STOP);
      // } else if (self->next_mode == "FINALE") {
      //   lf_set_mode(THIS_IS_WHAT_YOU_CAME_FOR);
      // }     
    =}

    // Function to write response from UART to received_message
    method receiveMessage(received_message: char*) {=
      char received_char;
      while (uart_is_readable(uart0)) { 
        received_char = uart_getc(uart0);
        if (received_char == '!') {
          received_message[self->i] = '\0'; // Null terminate the string
          self->i = 0;
          setCommand();
        } else if (self->i < MAX_MSG_LENGTH - 1) {
          received_message[self->i] = received_char;
          self->i += 1;
        }
      }
    =}


    // Function to send a message. The message that was transmitted is written to transmitted_message
    method transmitMessage(message: char*, transmitted_message: char*) {=
      int index = 0;
      while (*message && index < MAX_MSG_LENGTH) {
        uart_putc(uart0, *message);
        transmitted_message[index] = *message;
        index++;
        message++;
      }
      uart_putc(uart0, '\r'); // Carriage return
      uart_putc(uart0, '\n'); // newline
      transmitted_message[index] = '\0';
    =}
  
    reaction(startup) -> d.line0, d.line1, d.line2 {=
        gpio_init(RED_LED_PIN);
        gpio_init(YELLOW_LED_PIN);
        gpio_init(GREEN_LED_PIN);

        gpio_set_dir(RED_LED_PIN, GPIO_OUT);
        gpio_set_dir(YELLOW_LED_PIN, GPIO_OUT);
        gpio_set_dir(GREEN_LED_PIN, GPIO_OUT);

        uart_init(uart0, BAUD_RATE);
        gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);
        gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);

        gpio_init(PICO_DEFAULT_LED_PIN);
        gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);

        lf_set(d.line0, "CALIBRATING");
        lf_set(d.line1, "Roll robot over");
        lf_set(d.line2, "light and dark.");

        // Clear UART buffer
        while (uart_is_readable(uart0)) {
            uart_getc(uart0);
        }       
      =}

      reaction(end_calibration) -> line.calibrate {=
        lf_set(line.calibrate, false);
      =}

    reaction(t) -> e.trigger, gyro.trigger, line.trigger, d.line2 {=
      lf_set(e.trigger, true);
      lf_set(gyro.trigger, true);
      lf_set(line.trigger, true);

      if (uart_is_readable(uart0)) {
      receiveMessage(self->received_message);
      }

      static char buf_received[17];
      printf("R: %s\n", self->received_message);
      snprintf(buf_received, 17, "R:%s", self->received_message);
      printf("B: %s\n", buf_received);
      lf_set(d.line2, buf_received);
      
      if (self->leds_on) {
        if (self->leds_blink) {
          gpio_put(RED_LED_PIN, !gpio_get(RED_LED_PIN));
          gpio_put(GREEN_LED_PIN, !gpio_get(GREEN_LED_PIN));
          gpio_put(YELLOW_LED_PIN, !gpio_get(YELLOW_LED_PIN));
        } else {
          gpio_put(RED_LED_PIN, 1);
          gpio_put(YELLOW_LED_PIN, 1);
          gpio_put(GREEN_LED_PIN, 1);   
        }
      } else {
        gpio_put(RED_LED_PIN, 0);
        gpio_put(YELLOW_LED_PIN, 0);
        gpio_put(GREEN_LED_PIN, 0);   
      }   
    =}

  reaction(line.reflect) -> d.line0, d.line1, d.line2, d.line3 {=
    lf_set(d.line0, "");
    lf_set(d.line1, "");
    lf_set(d.line2, "");
    static char buf0[17];
    snprintf(buf0, 17, "1:%d, 2:%d", line.reflect->value[0], line.reflect->value[1]);
    static char buf1[17];
    snprintf(buf1, 17, "3:%d", line.reflect->value[2]);
    static char buf2[17];
    snprintf(buf2, 17, "4:%d, 5:%d", line.reflect->value[3], line.reflect->value[4]);
    lf_set(d.line0, buf0);
    lf_set(d.line1, buf1);
    lf_set(d.line2, buf2);
    self->one = line.reflect->value[0];
    self->two = line.reflect->value[1];
    self->three = line.reflect->value[2];
    self->four = line.reflect->value[3];
    self->five = line.reflect->value[4];
  =}
  
    e.left -> angleToDistanceL.degrees
    e.right -> angleToDistanceR.degrees

   // Initially rotate 10 turns to calibrate gyroscope
    initial mode CALIBRATION {
      reaction(t) -> m.left_power, m.right_power {=
        lf_set(m.left_power, 0.1f); 
        lf_set(m.right_power, 0.1f);      
      =}
      reaction(end_calibration) -> NEW_DRIVING {=
      lf_set_mode(NEW_DRIVING);
      =} 
    }
    // General mode taking in speed and leds_on
    mode NEW_DRIVING {
      reaction(angleToDistanceR.distance) gyro.z -> m.left_power, m.right_power, d.line0, d.line3, NEW_ROTATING {=
        static char buf[17];
        snprintf(buf, 17, "targetXDist:%i", self->target_x);
      //  lf_set(d.line1, buf);
        //For 90 degree right turn 
        if (self->one > 150 && self->three > 700 && self->five > 150 && self->commandReceived) {
          lf_set(m.left_power, 0.0f); 
          lf_set(m.right_power, 0.0f);
          self->previousDistance = angleToDistanceR.distance->value;
          self->previousAngle = gyro.z->value; 
          lf_set_mode(NEW_ROTATING);
        } else {
          lf_set(d.line3, "DRIVE");
          if (self->two > self->four && abs(self->two - self->four) > 100) {
            lf_set(m.left_power, self->speed);
            lf_set(m.right_power, self->speed + self->speed/10);
          } else if (self->two < self->four && abs(self->two - self->four) > 100) {
            lf_set(m.left_power, self->speed + self->speed/10);
            lf_set(m.right_power, self->speed);
          }
          else {
            lf_set(m.left_power, self->speed);
            lf_set(m.right_power, self->speed);
          }
        }
      =}
      }

    mode NEW_ROTATING {
      reaction(t) -> m.left_power, m.right_power, d.line0, d.line3, NEW_DRIVING {=
        static char buf[17];
        snprintf(buf, 17, "targetZ:%i", self->degrees);
       // lf_set(d.line3, buf);
        if (self->degrees == 90) { //turn right
          if (self->one > 0 && self->one < 30 && self->five > 0 && self->five < 30) {
            lf_set(m.left_power, 0.0f);
            lf_set_mode(NEW_DRIVING);
          } else {
              lf_set(d.line3, "ROTATE");
              lf_set(m.left_power, self->speed);
          }
        }
        else if (self->degrees == -90) { //turn left
          if (self->one > 0 && self->one < 30 && self->five > 0 && self->five < 30) {
            lf_set(m.right_power, 0.0f);
            lf_set_mode(NEW_DRIVING);
          } else {
              lf_set(d.line3, "ROTATE");
              lf_set(m.right_power, self->speed);
          }
        }
      =}
    }

    mode STOP {
      timer t1(0, 2 sec);
      reaction(t1) -> m.left_power, m.right_power, d.line0, NEW_DRIVING, NEW_ROTATING {=
        lf_set(m.left_power, 0.0f);
        lf_set(m.right_power, 0.0f);
        if (self->next_mode == "NEW_DRIVING") {
          lf_set_mode(NEW_DRIVING);
        } else {
          lf_set_mode(NEW_ROTATING);
        }
      =}
    }

    // mode THIS_IS_WHAT_YOU_CAME_FOR {
    //   reaction(t) gyro.z, angleToDistanceR.distance -> m.left_power, m.right_power, d.line0, NEW_DRIVING {=
    //     if (gyro.z->value - self->previousAngle <= -3570) {
    //       lf_set(m.left_power, 0.0f);
    //       self->previousAngle = gyro.z->value;
    //       self->previousDistance = angleToDistanceR.distance->value;
    //       lf_set_mode(NEW_DRIVING);
    //     } else {
    //       lf_set(d.line0, "FINALE");
    //       lf_set(m.left_power, 0.9);
    //     }
    //   =}
    // }
  }