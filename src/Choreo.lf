target C {
    platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
    },
    threading: false,
  }
  
  import Display from "lib/Display.lf"
  import Motors from "lib/Motors.lf"
  import Encoders from "lib/Encoders.lf"
  import GyroAngle from "lib/IMU.lf"
  import AngleToDistance from "lib/AngleToDistance.lf"
  
  preamble {=
    #include <math.h>
    #include <stdlib.h>
    #include <stdio.h>
    #include <pico/stdlib.h>
    #include <hardware/gpio.h>
    #include <hardware/uart.h>
    #include <hardware/structs/uart.h>

    #define BAUD_RATE 9600
    #define UART_TX_PIN 28
    #define UART_RX_PIN 29
    #define MAX_MSG_LENGTH 100

    #define RED_LED_PIN 7
    #define YELLOW_LED_PIN 27
    #define GREEN_LED_PIN 24

  =}
  
  main reactor {
    state transmitted_message:char[100] = "";
    state received_message:char[100] = "";
    state previousDistance:float = 0
    state previousAngle:float = 0
    state curr_mode:char[100] = "";
    state leds_on:bool = false
    state leds_speed:float = 0.0
    state speed:float = 0.0
    state target_distance:float = 0.0
    state num_rotations:int = 0
    state leds_blink:bool = false
    state i:int = 0
    state leds_state:bool = false
  
    m = new Motors()
    e = new Encoders()
    d = new Display()
    gyro = new GyroAngle()
    angleToDistanceL = new AngleToDistance()
    angleToDistanceR = new AngleToDistance()
  
    timer t(0, 50 ms)

    method setCommand() {=
      if (self->received_message[0] == '0') {
        self->curr_mode = "NEW_DRIVING";
      }
      if (self->received_message[1] == '0') {
        self->speed = 0.0f;
      }
      if (self->received_message[1] == '1') {
        self->speed = 0.25f;
      }
      if (self->received_message[1] == '2') {
        self->speed = 0.5f;
      }
      if (self->received_message[1] == '3') {
        self->speed = 0.75f;
      }
      // FIXME: atof function does not work. Need to convert str to float another way
      // self->leds_on = 1; //atoi(self->received_message[2]);
      if (self->received_message[2] == '0') {
        self->leds_on = false;
      }
      else if (self->received_message[2] == '1') {
        self->leds_on = true;
      }
      // FIXME: atof function does not work. Need to convert str to float another way
      self->target_distance = 0.5;
      if (self->received_message[4] == '0') {
        self->leds_blink = false;
      }
      else if (self->received_message[4] == '1') {
        self->leds_blink = true;
      }
      self->num_rotations = 2; //atoi(self->received_message[5]);
    =}

    // Function to write response from UART to received_message
    method receiveMessage(received_message: char*) {=
      char received_char;
      while (uart_is_readable(uart0)) { 
        received_char = uart_getc(uart0);
        if (received_char == '!') {
          received_message[self->i] = '\0'; // Null terminate the string
          self->i = 0;
          setCommand();
        } else if (self->i < MAX_MSG_LENGTH - 1) {
          received_message[self->i] = received_char;
          self->i += 1;
        }
      }
     // received_message[i] = '\0'; // Null terminate the string
    =}


    // Function to send a message. The message that was transmitted is written to transmitted_message
    method transmitMessage(message: char*, transmitted_message: char*) {=
      int index = 0;
      while (*message && index < MAX_MSG_LENGTH) {
        uart_putc(uart0, *message);
        transmitted_message[index] = *message;
        index++;
        message++;
      }
      uart_putc(uart0, '\r'); // Carriage return
      uart_putc(uart0, '\n'); // newline
      transmitted_message[index] = '\0';
    =}
  
    reaction(startup) {=
        gpio_init(RED_LED_PIN);
        gpio_init(YELLOW_LED_PIN);
        gpio_init(GREEN_LED_PIN);

        gpio_set_dir(RED_LED_PIN, GPIO_OUT);
        gpio_set_dir(YELLOW_LED_PIN, GPIO_OUT);
        gpio_set_dir(GREEN_LED_PIN, GPIO_OUT);

        uart_init(uart0, BAUD_RATE);
        gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);
        gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);

        gpio_init(PICO_DEFAULT_LED_PIN);
        gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);

        // Clear UART buffer
        while (uart_is_readable(uart0)) {
            uart_getc(uart0);
        }       
      =}

    reaction(t) -> e.trigger, gyro.trigger, d.line2 {=
      lf_set(e.trigger, true);
      lf_set(gyro.trigger, true);

      if (uart_is_readable(uart0)) {
      receiveMessage(self->received_message);
      }

      static char buf_received[17];
      printf("R: %s\n", self->received_message);
      snprintf(buf_received, 17, "R:%s", self->received_message);
      printf("B: %s\n", buf_received);
      lf_set(d.line2, buf_received);
      
      if (self->leds_on) {
        if (self->leds_blink) {
          gpio_put(RED_LED_PIN, !gpio_get(RED_LED_PIN));
          gpio_put(GREEN_LED_PIN, !gpio_get(GREEN_LED_PIN));
          gpio_put(YELLOW_LED_PIN, !gpio_get(YELLOW_LED_PIN));
        } else {
          gpio_put(RED_LED_PIN, 1);
          gpio_put(YELLOW_LED_PIN, 1);
          gpio_put(GREEN_LED_PIN, 1);   
        }
        } else {
          gpio_put(RED_LED_PIN, 0);
          gpio_put(YELLOW_LED_PIN, 0);
          gpio_put(GREEN_LED_PIN, 0);    
      }   
    =}
  
    e.left -> angleToDistanceL.degrees
    e.right -> angleToDistanceR.degrees
  
    // mode DRIVING {
    //   reaction(angleToDistanceR.distance) gyro.z -> m.left_power, m.right_power, d.line0, ROTATING {=
    //     if (self->leds_on) {
    //       gpio_put(RED_LED_PIN, 1);
    //       gpio_put(YELLOW_LED_PIN, 0);
    //       gpio_put(GREEN_LED_PIN, 1);
    //       self->leds_on = !self->leds_on;
    //     }
    //     else {
    //       gpio_put(RED_LED_PIN, 0);
    //       gpio_put(YELLOW_LED_PIN, 1);
    //       gpio_put(GREEN_LED_PIN, 0);
    //       self->leds_on = !self->leds_on;
    //     }
    //     if (angleToDistanceR.distance->value - self->previousDistance > 1.0) {
    //       lf_set(m.left_power, 0.0f);
    //       lf_set(m.right_power, 0.0f);
    //       self->previousDistance = angleToDistanceR.distance->value;
    //       self->previousAngle = gyro.z->value; 
    //       lf_set_mode(ROTATING);
    //     } else {
    //       lf_set(d.line0, "DRIVE");
    //       lf_set(m.left_power, 0.5f);
    //       lf_set(m.right_power, 0.5f);
          
    //     }
    //   =}
    // }
  
    // mode ROTATING {
    //   reaction(gyro.z) -> m.left_power, m.right_power, d.line0, DRIVING {=
    //     if (gyro.z->value - self->previousAngle < -1080.0) {
    //       lf_set(m.left_power, 0.0f);
    //       self->previousAngle = gyro.z->value;
    //       lf_set_mode(DRIVING);
    //     } else {
    //       lf_set(d.line0, "ROTATE");
    //       lf_set(m.left_power, 1.0f);
    //     }
    //   =}
    // }

    //General mode taking in speed and leds_on
    initial mode NEW_DRIVING {
      reaction(angleToDistanceR.distance) gyro.z -> m.left_power, m.right_power, d.line0, d.line1, NEW_ROTATING {=

        static char buf[17];
        snprintf(buf, 17, "targetDist:%f", self->target_distance);
        lf_set(d.line1, buf);
        if (angleToDistanceR.distance->value - self->previousDistance > self->target_distance) {
          lf_set(m.left_power, 0.0f); 
          lf_set(m.right_power, 0.0f);
          self->previousDistance = angleToDistanceR.distance->value;
          self->previousAngle = gyro.z->value; 
          lf_set_mode(NEW_ROTATING);
        } else {
          lf_set(d.line0, "DRIVE");
          lf_set(m.left_power, self->speed);
          lf_set(m.right_power, self->speed);
        }
      =}
    }

    mode NEW_ROTATING {
      reaction(gyro.z) -> m.left_power, m.right_power, d.line0, d.line3, NEW_DRIVING {=
        static char buf[17];
        snprintf(buf, 17, "targetZ:%i", -self->num_rotations * 360);
        lf_set(d.line3, buf);
        if (gyro.z->value - self->previousAngle < -self->num_rotations * 360) {
          lf_set(m.left_power, 0.0f);
          self->previousAngle = gyro.z->value;
          lf_set_mode(NEW_DRIVING);
        } else {
          lf_set(d.line0, "ROTATE");
          lf_set(m.left_power, self->speed);
        }
      =}
    }
  }