target C {
    platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
    },
    threading: false,
  }
  
  import Display from "lib/Display.lf"
  import Motors from "lib/Motors.lf"
  import Encoders from "lib/Encoders.lf"
  import GyroAngle from "lib/IMU.lf"
  import AngleToDistance from "lib/AngleToDistance.lf"
  
  preamble {=
    #include <math.h>
    #include <stdlib.h>
    #include <stdio.h>
    #include <pico/stdlib.h>
    #include <hardware/gpio.h>
    #include <hardware/uart.h>
    #include <hardware/structs/uart.h>

    #define BAUD_RATE 9600
    #define UART_TX_PIN 28
    #define UART_RX_PIN 29
    #define MAX_MSG_LENGTH 100

    #define RED_LED_PIN 7
    #define YELLOW_LED_PIN 27
    #define GREEN_LED_PIN 24

  =}
  
  main reactor {
    state transmitted_message:char[100] = "";
    state received_message:char[100] = "";
    state previousDistance:float = 0
    state previousAngle:float = 0
    state curr_mode:char[100] = "";
    state leds_on:int = 0
    state leds_speed:float = 0.0
    state speed:float = 0.0
    state target_distance:float = 0.0
    state num_rotations:int = 0
    state leds_blink:int = 0
    state i:int = 0
    state leds_state:int = 0
    state calibration_speed:float = 0.0
  
    m = new Motors()
    e = new Encoders()
    d = new Display()
    gyro = new GyroAngle()
    angleToDistanceL = new AngleToDistance()
    angleToDistanceR = new AngleToDistance()
  
    timer t(0, 50 ms)

    method setCommand() {=
      if (self->received_message[0] == '0') {
        self->curr_mode = "NEW_DRIVING";
      }
      self->speed = (float)(self->received_message[1] - '0') / 10.0;
      self->leds_on = self->received_message[2] - '0';
      self->target_distance = (float)(self->received_message[3] - '0') / 10.0;
      self->leds_blink = self->received_message[4] - '0';
      self->num_rotations = self->received_message[5] - '0';
      self->calibration_speed = 0.5f;
    =}

    // Function to write response from UART to received_message
    method receiveMessage(received_message: char*) {=
      char received_char;
      while (uart_is_readable(uart0)) { 
        received_char = uart_getc(uart0);
        if (received_char == '!') {
          received_message[self->i] = '\0'; // Null terminate the string
          self->i = 0;
          setCommand();
        } else if (self->i < MAX_MSG_LENGTH - 1) {
          received_message[self->i] = received_char;
          self->i += 1;
        }
      }
     // received_message[i] = '\0'; // Null terminate the string
    =}


    // Function to send a message. The message that was transmitted is written to transmitted_message
    method transmitMessage(message: char*, transmitted_message: char*) {=
      int index = 0;
      while (*message && index < MAX_MSG_LENGTH) {
        uart_putc(uart0, *message);
        transmitted_message[index] = *message;
        index++;
        message++;
      }
      uart_putc(uart0, '\r'); // Carriage return
      uart_putc(uart0, '\n'); // newline
      transmitted_message[index] = '\0';
    =}
  
    reaction(startup) {=
        gpio_init(RED_LED_PIN);
        gpio_init(YELLOW_LED_PIN);
        gpio_init(GREEN_LED_PIN);

        gpio_set_dir(RED_LED_PIN, GPIO_OUT);
        gpio_set_dir(YELLOW_LED_PIN, GPIO_OUT);
        gpio_set_dir(GREEN_LED_PIN, GPIO_OUT);

        uart_init(uart0, BAUD_RATE);
        gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);
        gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);

        gpio_init(PICO_DEFAULT_LED_PIN);
        gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);

        // Clear UART buffer
        while (uart_is_readable(uart0)) {
            uart_getc(uart0);
        }       
      =}

    reaction(t) -> e.trigger, gyro.trigger, d.line2 {=
      lf_set(e.trigger, true);
      lf_set(gyro.trigger, true);

      if (uart_is_readable(uart0)) {
      receiveMessage(self->received_message);
      }

      static char buf_received[17];
      printf("R: %s\n", self->received_message);
      snprintf(buf_received, 17, "R:%s", self->received_message);
      printf("B: %s\n", buf_received);
      lf_set(d.line2, buf_received);

      // static char buf_received[17];
      // snprintf(buf_received, 17, "LEDS ON:%d", self->leds_on);
      // lf_set(d.line2, buf_received);
      
      if (self->leds_on) {
        if (self->leds_blink) {
          gpio_put(RED_LED_PIN, !gpio_get(RED_LED_PIN));
          gpio_put(GREEN_LED_PIN, !gpio_get(GREEN_LED_PIN));
          gpio_put(YELLOW_LED_PIN, !gpio_get(YELLOW_LED_PIN));
        } else {
          gpio_put(RED_LED_PIN, 1);
          gpio_put(YELLOW_LED_PIN, 1);
          gpio_put(GREEN_LED_PIN, 1);   
        }
      } else {
        gpio_put(RED_LED_PIN, 0);
        gpio_put(YELLOW_LED_PIN, 0);
        gpio_put(GREEN_LED_PIN, 0);    
      }   
    =}
  
    e.left -> angleToDistanceL.degrees
    e.right -> angleToDistanceR.degrees

    //General mode taking in speed and leds_on
    initial mode CALIBRATION {
      reaction(t) gyro.z, angleToDistanceR.distance -> m.left_power, m.right_power, d.line0, NEW_DRIVING {=
        if (gyro.z->value - self->previousAngle <= -3570) {
          lf_set(m.left_power, 0.0f);
          self->previousAngle = gyro.z->value;
          self->previousDistance = angleToDistanceR.distance->value;
          lf_set_mode(NEW_DRIVING);
        } else {
          lf_set(d.line0, "CALIBRATE");
          lf_set(m.left_power, self->calibration_speed);
        }
      =}
    }

    mode NEW_DRIVING {
      reaction(angleToDistanceR.distance) gyro.z -> m.left_power, m.right_power, d.line0, d.line1, NEW_ROTATING {=

        static char buf[17];
        snprintf(buf, 17, "targetDist:%f", self->target_distance);
        lf_set(d.line1, buf);
        if (angleToDistanceR.distance->value - self->previousDistance >= self->target_distance) {
          lf_set(m.left_power, 0.0f); 
          lf_set(m.right_power, 0.0f);
          self->previousDistance = angleToDistanceR.distance->value;
          self->previousAngle = gyro.z->value; 
          lf_set_mode(NEW_ROTATING);
        } else {
          lf_set(d.line0, "DRIVE");
          lf_set(m.left_power, self->speed);
          lf_set(m.right_power, self->speed - 0.005f);
        }
      =}
    }

    mode NEW_ROTATING {
      reaction(gyro.z) angleToDistanceR.distance -> m.left_power, m.right_power, d.line0, d.line3, NEW_DRIVING {=
        static char buf[17];
        snprintf(buf, 17, "targetZ:%i", -self->num_rotations * 360);
        lf_set(d.line3, buf);
        if (gyro.z->value - self->previousAngle <= -self->num_rotations * 348) {
          lf_set(m.left_power, 0.0f);
          self->previousAngle = gyro.z->value;
          self->previousDistance = angleToDistanceR.distance->value;
          lf_set_mode(NEW_DRIVING);
        } else {
          lf_set(d.line0, "ROTATE");
          lf_set(m.left_power, self->speed);
        }
      =}
    }

    // mode THIS_IS_WHAT_YOU_CAME_FOR {
    //   reaction(t) gyro.z, angleToDistanceR.distance -> m.left_power, m.right_power, d.line0, NEW_DRIVING {=
    //     if (gyro.z->value - self->previousAngle <= -3570) {
    //       lf_set(m.left_power, 0.0f);
    //       self->previousAngle = gyro.z->value;
    //       self->previousDistance = angleToDistanceR.distance->value;
    //       lf_set_mode(NEW_DRIVING);
    //     } else {
    //       lf_set(d.line0, "FINALE");
    //       lf_set(m.left_power, 0.9);
    //     }
    //   =}
    // }
  }