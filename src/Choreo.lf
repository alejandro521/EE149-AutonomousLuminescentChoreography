target C {
  platform: {
    name: "rp2040",
    board: "pololu_3pi_2040_robot"
  },
  threading: false,
}

import Display from "lib/Display.lf"
import Motors from "lib/Motors.lf"
import Encoders from "lib/Encoders.lf"
import GyroAngle from "lib/IMU.lf"
import AngleToDistance from "lib/AngleToDistance.lf"
import Line from "lib/Line.lf"

preamble {=
  #include <math.h>
  #include <stdlib.h>
  #include <stdio.h>
  #include <pico/stdlib.h>
  #include <hardware/gpio.h>
  #include <hardware/uart.h>
  #include <hardware/structs/uart.h>

  #define BAUD_RATE 9600
  #define UART_TX_PIN 28
  #define UART_RX_PIN 29
  #define MAX_MSG_LENGTH 100

  #define RED_LED_PIN 7
  #define YELLOW_LED_PIN 27
  #define GREEN_LED_PIN 24

=}

main reactor {
  state transmitted_message:char[100] = "";
  state received_message:char[100] = "";
  state previousDistance:float = 0
  state previousAngle:float = 0
  state next_mode:char[100] = "";
  state leds_on:int = 0
  state leds_speed:float = 0.0
  state speed:float = 0.0
  state target_distance:float = 0.0
  state degrees:int = 0
  state leds_blink:int = 0
  state i:int = 0
  state leds_state:int = 0
  state x: int = 0
  state y: int = 0
  state leftLine: int = 0
  state centerLine: int = 0
  state rightLine: int = 0
  state threshold: int = 200
  
  m = new Motors()
  e = new Encoders()
  d = new Display()
  gyro = new GyroAngle()
  angleToDistanceL = new AngleToDistance()
  angleToDistanceR = new AngleToDistance()
  line = new Line()

  timer t(0, 50 ms)

  method setCommand() {=
    char *token = strtok(self->received_message, ",");
    self->next_mode = token;
    token = strtok(NULL, ",");
    self->speed = atof(token);
    token = strtok(NULL, ",");
    self->degrees = atoi(token);
    token = strtok(NULL, ",");
    self->target_distance = atof(token);
    token = strtok(NULL, ",");
    self->leds_on = atoi(token);
    token = strtok(NULL, ",");
    self->leds_blink = atoi(token);
    token = strtok(NULL, ",");  
  =}

  // Function to write response from UART to received_message
  method receiveMessage(received_message: char*) {=
    char received_char;
    while (uart_is_readable(uart0)) { 
      received_char = uart_getc(uart0);
      if (received_char == '!') {
        received_message[self->i] = '\0'; // Null terminate the string
        self->i = 0;
        setCommand();
      } else if (self->i < MAX_MSG_LENGTH - 1) {
        received_message[self->i] = received_char;
        self->i += 1;
      }
    }
  =}


  // Function to send a message. The message that was transmitted is written to transmitted_message
  method transmitMessage(message: char*, transmitted_message: char*) {=
    int index = 0;
    while (*message && index < MAX_MSG_LENGTH) {
      uart_putc(uart0, *message);
      transmitted_message[index] = *message;
      index++;
      message++;
    }
    uart_putc(uart0, '\r'); // Carriage return
    uart_putc(uart0, '\n'); // newline
    transmitted_message[index] = '\0';
  =}

  reaction(startup) -> d.line0, d.line1, d.line2{=
      gpio_init(RED_LED_PIN);
      gpio_init(YELLOW_LED_PIN);
      gpio_init(GREEN_LED_PIN);

      gpio_set_dir(RED_LED_PIN, GPIO_OUT);
      gpio_set_dir(YELLOW_LED_PIN, GPIO_OUT);
      gpio_set_dir(GREEN_LED_PIN, GPIO_OUT);

      uart_init(uart0, BAUD_RATE);
      gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);
      gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);

      gpio_init(PICO_DEFAULT_LED_PIN);
      gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);

      // Clear UART buffer
      while (uart_is_readable(uart0)) {
          uart_getc(uart0);
      }       
    =}

  reaction(t) -> e.trigger, gyro.trigger, line.trigger, d.line2 {=
    lf_set(e.trigger, true);
    lf_set(gyro.trigger, true);
    lf_set(line.trigger, true);

    if (uart_is_readable(uart0)) {
    receiveMessage(self->received_message);
    }

    static char buf_received[17];
    printf("R: %s\n", self->received_message);
    snprintf(buf_received, 17, "R:%s", self->received_message);
    printf("B: %s\n", buf_received);
    lf_set(d.line2, buf_received);
    
    if (self->leds_on) {
      if (self->leds_blink) {
        gpio_put(RED_LED_PIN, !gpio_get(RED_LED_PIN));
        gpio_put(GREEN_LED_PIN, !gpio_get(GREEN_LED_PIN));
        gpio_put(YELLOW_LED_PIN, !gpio_get(YELLOW_LED_PIN));
      } else {
        gpio_put(RED_LED_PIN, 1);
        gpio_put(YELLOW_LED_PIN, 1);
        gpio_put(GREEN_LED_PIN, 1);   
      }
    } else {
      gpio_put(RED_LED_PIN, 0);
      gpio_put(YELLOW_LED_PIN, 0);
      gpio_put(GREEN_LED_PIN, 0);   
    }   
  =}

  reaction(line.reflect) -> d.line0, d.line1, d.line2, d.line3 {=
    self->leftLine = line.reflect->value[0];
    self->centerLine = (line.reflect->value[1] + line.reflect->value[2] + line.reflect->value[3]) / 3;
    self->leftLine = line.reflect->value[4];
    static char buf0[17];
    snprintf(buf0, 17, "1:%d", line.reflect->value[0]);
    static char buf1[17];
    snprintf(buf1, 17, "2: %d, 3:%d, 4:%d", line.reflect->value[1], line.reflect->value[2], line.reflect->value[3]);
    static char buf2[17];
    snprintf(buf2, 17, "5:%d", line.reflect->value[4]);
    lf_set(d.line0, buf0);
    lf_set(d.line1, buf1);
    lf_set(d.line2, buf2);
  =}

  e.left -> angleToDistanceL.degrees
  e.right -> angleToDistanceR.degrees

  // Initially rotate 10 turns to the right to calibrate gyroscope
  initial mode CALIBRATION {
    reaction(t) gyro.z, angleToDistanceR.distance -> m.left_power, m.right_power, d.line0, NEW_DRIVING, STOP {=
      if (gyro.z->value - self->previousAngle <= -3560) {
        lf_set(m.left_power, 0.0f);
        self->previousAngle = gyro.z->value;
        self->previousDistance = angleToDistanceR.distance->value;
        transmitMessage("Done");
        lf_set_mode(STOP);
      } else {
        lf_set(d.line0, "CALIBRATE");
        lf_set(m.left_power, 0.5f);
      }
    =}
    }

  // General mode taking in speed and leds_on
  mode NEW_DRIVING {
    reaction(angleToDistanceR.distance) gyro.z -> m.left_power, m.right_power, d.line0, d.line1, d.line2, d.line3, NEW_ROTATING, STOP {=
      lf_set(d.line0, "DRIVE");
      if (strcmp(self->next_mode, "Stop") == 0){
        self->next_mode = "";
        lf_set_mode(STOP);
      } else if (strcmp(self->next_mode, "Rotate") == 0) {
        self->next_mode = "";
        lf_set_mode(NEW_ROTATING);
      }
      static char buf[17];
      snprintf(buf, 17, "targetDist:%f", self->target_distance);
      // lf_set(d.line1, buf);
      if (angleToDistanceR.distance->value - self->previousDistance >= self->target_distance) {
        self->previousDistance = angleToDistanceR.distance->value;
        self->previousAngle = gyro.z->value; 
        self->next_mode = "";
        transmitMessage("Done", buf);
        lf_set(d.line1, buf);
        lf_set_mode(STOP);
      } else {
        lf_set(m.left_power, self->speed);
        lf_set(m.right_power, self->speed);
      }
    =}
    }

  mode NEW_ROTATING {
    reaction(gyro.z) angleToDistanceR.distance -> m.left_power, m.right_power, d.line0, d.line3, NEW_DRIVING, STOP {=
      lf_set(d.line0, "ROTATE");
      if (strcmp(self->next_mode, "Stop") == 0) {
        self->next_mode = "";
        lf_set_mode(STOP);
      } else if (strcmp(self->next_mode, "Drive") == 0) {
        self->next_mode = "";
        lf_set_mode(NEW_DRIVING);
      }
      static char buf[17];
      snprintf(buf, 17, "targetZ:%i", self->degrees);
      if (abs(gyro.z->value - self->previousAngle) >= abs(self->degrees)) {
        self->previousAngle = gyro.z->value;
        self->previousDistance = angleToDistanceR.distance->value;
        self->next_mode = "";
        transmitMessage("Done", buf);
        lf_set(d.line1, buf);
        lf_set_mode(STOP);
      } else {
        if (self->degrees < 0) { //Rotate left  
          lf_set(m.right_power, self->speed);
        } else { //Rotate right
          lf_set(m.left_power, self->speed);
        }
      }
    =}
  }

  mode STOP {
    timer t1(0, 1 sec);
    reaction(t1) -> m.left_power, m.right_power, d.line0, NEW_DRIVING, NEW_ROTATING {=
      lf_set(m.left_power, 0.0f);
      lf_set(m.right_power, 0.0f);
      lf_set(d.line0, "STOP");
      if (strcmp(self->next_mode, "Drive") == 0) {
        self->next_mode = "";
        lf_set_mode(NEW_DRIVING);
      } else if (strcmp(self->next_mode, "Rotate") == 0){
        self->next_mode = "";
        lf_set_mode(NEW_ROTATING);
      }
    =}
  }

  // mode THIS_IS_WHAT_YOU_CAME_FOR {
  //   reaction(t) gyro.z, angleToDistanceR.distance -> m.left_power, m.right_power, d.line0, NEW_DRIVING {=
  //     if (gyro.z->value - self->previousAngle <= -3570) {
  //       lf_set(m.left_power, 0.0f);
  //       self->previousAngle = gyro.z->value;
  //       self->previousDistance = angleToDistanceR.distance->value;
  //       lf_set_mode(NEW_DRIVING);
  //     } else {
  //       lf_set(d.line0, "FINALE");
  //       lf_set(m.left_power, 0.9);
  //     }
  //   =}
  // }
}