target C {
  platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
  },
  threading: false,
}

import MotorsWithFeedback from "lib/MotorsWithFeedback.lf"
import Encoders from "lib/Encoders.lf"

preamble {=
  #include <stdio.h>
  #include <pico/stdlib.h>
  #include <hardware/gpio.h>

  #define RED_LED_PIN 7
  #define YELLOW_LED_PIN 27
  #define GREEN_LED_PIN 24
=}

reactor Robot {
  input drive_mode:int; //0 = stopped, 1 = driving, 2 = turning
  input direction:int; //0 = forwards or left, 1 = backwards or right
  input leds_on: int; //0 = off, 1 = on 
  input leds_blink: int; //0 = off, 1 = on
  input target_distance: int; //in cm
  encoders = new Encoders()
  motors = new MotorsWithFeedback()
  encoders.left -> motors.left;
  encoders.right -> motors.right;

  state orientation: float = 0;
  state left_speed: float = 0.15;
  state right_speed: float = 0.15;

  timer t(0, 10 ms);

  initial mode STOPPED {
    reaction(drive_mode) -> STOPPED, DRIVING, TURNING {=
      switch (drive_mode->value) {
        case 0: 
          lf_set_mode(STOPPED);
          break;
        case 1:
          lf_set_mode(DRIVING);
          break;
        case 2:
          lf_set_mode(TURNING);
      }
    =}
    
    reaction(t) -> motors.left_speed, motors.right_speed, encoders.trigger {=
      lf_set(encoders.trigger, !encoders.trigger->value);
      lf_set(motors.left_speed, 0);
      lf_set(motors.right_speed, 0);
    =}
  }

  mode DRIVING {
    reaction(drive_mode) -> STOPPED, DRIVING, TURNING {=
      switch (drive_mode->value) {
        case 0: 
          lf_set_mode(STOPPED);
          break;
        case 1:
          lf_set_mode(DRIVING);
          break;
        case 2:
          lf_set_mode(TURNING);
      }
    =}

    reaction(leds_on, leds_blink) {=
      if (leds_on->value) {
        if (leds_blink->value) {
          gpio_put(RED_LED_PIN, !gpio_get(RED_LED_PIN));
          gpio_put(GREEN_LED_PIN, !gpio_get(GREEN_LED_PIN));
          gpio_put(YELLOW_LED_PIN, !gpio_get(YELLOW_LED_PIN));
        } else {
          gpio_put(RED_LED_PIN, 1);
          gpio_put(YELLOW_LED_PIN, 1);
          gpio_put(GREEN_LED_PIN, 1);    
        }
      } else {
        gpio_put(RED_LED_PIN, 0);
        gpio_put(YELLOW_LED_PIN, 0);
        gpio_put(GREEN_LED_PIN, 0);   
      }  
    =}

    reaction(t, direction) -> motors.left_speed, motors.right_speed, encoders.trigger {=
      lf_set(encoders.trigger, !encoders.trigger->value);
      if (direction->value) {
        lf_set(motors.left_speed, -self->left_speed);
        lf_set(motors.right_speed, -self->right_speed);
      } else {
        lf_set(motors.left_speed, self->left_speed);
        lf_set(motors.right_speed, self->right_speed);
      }
    =}
  }

  mode TURNING {
    reaction(drive_mode) -> STOPPED, DRIVING, TURNING {=
      switch (drive_mode->value) {
        case 0: 
          lf_set_mode(STOPPED);
          break;
        case 1:
          lf_set_mode(DRIVING);
          break;
        case 2:
          lf_set_mode(TURNING);
      }
    =}

    reaction(t, direction) -> motors.left_speed, motors.right_speed, encoders.trigger {=
      lf_set(encoders.trigger, !encoders.trigger->value);
      if (direction->value) {
        lf_set(motors.left_speed, -self->left_speed);
        lf_set(motors.right_speed, self->right_speed);
      } else {
        lf_set(motors.left_speed, self->left_speed);
        lf_set(motors.right_speed, -self->right_speed);
      }
    =}
  }
}