target C {
    platform: {
        name: "rp2040",
        board: "pololu_3pi_2040_robot"
    },
    threading: false,
  }
  
  import Display from "lib/Display.lf"
  import Robot from "PololuControl.lf"
  import Accelerometer from "lib/IMU.lf"
  
  preamble {=
    #include <stdio.h>
    #include <pico/stdlib.h>
    #include <hardware/gpio.h>
    #include <hardware/uart.h>
    #include <hardware/structs/uart.h>
  
    #define BAUD_RATE 9600
    #define UART_TX_PIN 28
    #define UART_RX_PIN 29
    #define MAX_MSG_LENGTH 100
    
    // COMMANDS TO POLOLU GO HERE
    static char SET_NAME_COMMAND[10] = "SET_NAME:";
    static char DRIVE_FORWARD_COMMAND[14] = "DRIVE_FORWARD";
    static char DRIVE_BACKWARD_COMMAND[15] = "DRIVE_BACKWARD";
    static char TURN_LEFT_COMMAND[10] = "TURN_LEFT";
    static char TURN_RIGHT_COMMAND[11] = "TURN_RIGHT";
  
    // Function to send a message. The message that was transmitted is written to transmitted_message
    static void transmitMessage(uart_inst_t *uart, char *message, char *transmitted_message) {
      int index = 0;
      while (*message && index < MAX_MSG_LENGTH) {
        uart_putc(uart, *message);
        transmitted_message[index] = *message;
        index++;
        message++;
      }
      uart_putc(uart, '\r'); // Carriage return
      transmitted_message[index] = '\0';
    }
  
    // Function to write response from UART to received_message
    static void receiveMessage(uart_inst_t *uart, char *received_message) {
      int index = 0;
      char received_char = 'a'; //'a' is just to initialize received_char to a character that is not \r
      char end_char = '\r';
      if (uart_is_readable(uart)) {
        while (received_char != end_char) { 
          received_char = uart_getc(uart);
          if (index < MAX_MSG_LENGTH - 1 && received_char != end_char) {
            received_message[index] = received_char;
            index += 1;
          }
        }
      }
      received_message[index] = '\0'; // Null terminate the string
    }
  
    static bool matchesCommand(command, str) {
      return strncmp(command, str, strlen(command)) == 0;
    }
  =}
  
  main reactor {
    timer t(0, 50 ms);
    state led_on:bool = false;
    state reply:char[100] = "";
    state transmitted_message:char[100] = "";
    state received_message:char[100] = "";
    state name: char[100] = ""
    state counter: int = 0 // Counter for bias
    state x: float = 0.0 // Bias for x
    state y: float = 0.0 // Bias for y
    disp = new Display();
    pololu = new Robot();
    acc = new Accelerometer();
  
  
    reaction(startup) {=
      uart_init(uart0, BAUD_RATE);
      gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);
      gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);
  
      gpio_init(PICO_DEFAULT_LED_PIN);
      gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);
  
      // Clear UART buffer
      while (uart_is_readable(uart0)) {
          uart_getc(uart0);
      }
  
    =}
  
    reaction(t) -> disp.line0, disp.line1, disp.line2 {=
      lf_set(disp.line0, self->name);
  
      // Display last transmitted message
      static char buf_sent[17];
      snprintf(buf_sent, 17, "S:%s", self->transmitted_message);
      lf_set(disp.line1, buf_sent);
  
      // Display last received message
      static char buf_received[17];
      printf("R: %s\n", self->received_message);
      snprintf(buf_received, 17, "R:%s", self->received_message);
      printf("B: %s\n", buf_received);
      lf_set(disp.line2, buf_received);
      
      // LED Blink
      self->led_on = !self->led_on;
      gpio_put(PICO_DEFAULT_LED_PIN, self->led_on);
    =}
  
    initial mode CALIBRATING {
        reaction(t) acc.x, acc.y {=
            while (self->counter < 6) {
                self->x += acc.x->value;
                self->y += acc.y->value;
                if (self->counter == 5) {
                    self->x /= 5;
                    self->y /=5;
                }
                self->counter += 1;
            }
        =}
    }
}